import { CopyObjectCommand, DeleteObjectCommand, GetObjectCommand, HeadObjectCommand, ListObjectsV2Command, S3Client, } from '@aws-sdk/client-s3';
import { Upload } from '@aws-sdk/lib-storage';
import { normalizePath } from '@directus/utils';
import { isReadableStream } from '@directus/utils/node';
import { join } from 'node:path';
export class DriverS3 {
    root;
    client;
    bucket;
    acl;
    serverSideEncryption;
    constructor(config) {
        const s3ClientConfig = {};
        if ((config.key && !config.secret) || (config.secret && !config.key)) {
            throw new Error('Both `key` and `secret` are required when defined');
        }
        if (config.key && config.secret) {
            s3ClientConfig.credentials = {
                accessKeyId: config.key,
                secretAccessKey: config.secret,
            };
        }
        if (config.endpoint) {
            const protocol = config.endpoint.startsWith('https://') ? 'https:' : 'http:';
            const hostname = config.endpoint.replace('https://', '').replace('http://', '');
            s3ClientConfig.endpoint = {
                hostname,
                protocol,
                path: '/',
            };
        }
        if (config.region) {
            s3ClientConfig.region = config.region;
        }
        if (config.forcePathStyle !== undefined) {
            s3ClientConfig.forcePathStyle = config.forcePathStyle;
        }
        this.client = new S3Client(s3ClientConfig);
        this.bucket = config.bucket;
        this.acl = config.acl;
        this.serverSideEncryption = config.serverSideEncryption;
        this.root = config.root ? normalizePath(config.root, { removeLeading: true }) : '';
    }
    fullPath(filepath) {
        return normalizePath(join(this.root, filepath));
    }
    async read(filepath, range) {
        const commandInput = {
            Key: this.fullPath(filepath),
            Bucket: this.bucket,
        };
        if (range) {
            commandInput.Range = `bytes=${range.start ?? ''}-${range.end ?? ''}`;
        }
        const { Body: stream } = await this.client.send(new GetObjectCommand(commandInput));
        if (!stream || !isReadableStream(stream)) {
            throw new Error(`No stream returned for file "${filepath}"`);
        }
        return stream;
    }
    async stat(filepath) {
        const { ContentLength, LastModified } = await this.client.send(new HeadObjectCommand({
            Key: this.fullPath(filepath),
            Bucket: this.bucket,
        }));
        return {
            size: ContentLength,
            modified: LastModified,
        };
    }
    async exists(filepath) {
        try {
            await this.stat(filepath);
            return true;
        }
        catch {
            return false;
        }
    }
    async move(src, dest) {
        await this.copy(src, dest);
        await this.delete(src);
    }
    async copy(src, dest) {
        const params = {
            Key: this.fullPath(dest),
            Bucket: this.bucket,
            CopySource: `/${this.bucket}/${this.fullPath(src)}`,
        };
        if (this.serverSideEncryption) {
            params.ServerSideEncryption = this.serverSideEncryption;
        }
        if (this.acl) {
            params.ACL = this.acl;
        }
        await this.client.send(new CopyObjectCommand(params));
    }
    async write(filepath, content, type) {
        const params = {
            Key: this.fullPath(filepath),
            Body: content,
            Bucket: this.bucket,
        };
        if (type) {
            params.ContentType = type;
        }
        if (this.acl) {
            params.ACL = this.acl;
        }
        if (this.serverSideEncryption) {
            params.ServerSideEncryption = this.serverSideEncryption;
        }
        const upload = new Upload({
            client: this.client,
            params,
        });
        await upload.done();
    }
    async delete(filepath) {
        await this.client.send(new DeleteObjectCommand({ Key: this.fullPath(filepath), Bucket: this.bucket }));
    }
    async *list(prefix = '') {
        let continuationToken = undefined;
        do {
            const listObjectsV2CommandInput = {
                Bucket: this.bucket,
                Prefix: this.fullPath(prefix),
                MaxKeys: 1000,
            };
            if (continuationToken) {
                listObjectsV2CommandInput.ContinuationToken = continuationToken;
            }
            const response = await this.client.send(new ListObjectsV2Command(listObjectsV2CommandInput));
            continuationToken = response.NextContinuationToken;
            if (response.Contents) {
                for (const file of response.Contents) {
                    if (file.Key) {
                        yield file.Key.substring(this.root.length);
                    }
                }
            }
        } while (continuationToken);
    }
}
export default DriverS3;
